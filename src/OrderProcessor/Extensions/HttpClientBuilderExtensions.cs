using Microsoft.Extensions.DependencyInjection;
using Polly;
using System.Net;

namespace OrderProcessor.Extensions;

public static class HttpClientBuilderExtensions
{
    private const int HttpClientTimeout = 60;

    public static IHttpClientBuilder ConfigureHttpClientCommon(
        this IHttpClientBuilder builder, int[] retryDelaysInSeconds)
    {
        bool RetryableResultPredicate(HttpResponseMessage msg) =>
            msg.StatusCode is >= HttpStatusCode.InternalServerError or HttpStatusCode.RequestTimeout or HttpStatusCode.TooManyRequests;

        return builder
            .ConfigureHttpClient(c => c.Timeout = TimeSpan.FromSeconds(HttpClientTimeout))
            .AddPolicyHandler(GetPolicyFactory(RetryableResultPredicate, retryDelaysInSeconds), _ => builder.Name);
    }

    private static Func<IServiceProvider, HttpRequestMessage, string, IAsyncPolicy<HttpResponseMessage>> GetPolicyFactory(
            Func<HttpResponseMessage, bool> retryableResultPredicate, int[] retryDelaysInSeconds)
    {
        IAsyncPolicy<HttpResponseMessage> PolicyFactory(IServiceProvider spDiscarded, HttpRequestMessage message, string keyDiscarded)
        {
            var circuitBreakerPolicy = Policy.Handle<HttpRequestException>()
                .OrResult(retryableResultPredicate)
                .AdvancedCircuitBreakerAsync(1.0, TimeSpan.FromSeconds(10), 10, TimeSpan.FromSeconds(15));

            var retryPolicy = Policy.Handle<HttpRequestException>()
                .OrResult(retryableResultPredicate)
                .WaitAndRetryAsync(
                    retryDelaysInSeconds.Select(s => TimeSpan.FromSeconds(s)));

            // circuitBreaker is inner to count unsuccessful requests generated by retries
            return Policy.WrapAsync(retryPolicy, circuitBreakerPolicy);
        }

        return PolicyFactory;
    }
}
